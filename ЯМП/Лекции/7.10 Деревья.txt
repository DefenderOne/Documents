Деревья
Бинарные деревья
Дерево - абстрактный тип данных для хранения информационных объектов, имеющих нелинейные отношения. За исключением элемента, находящегося
во главе дерева, каждый элемент имеет родителя, а так же ноль или более дочерних элементов. Каждый элемент дерева называется вершиной или узлом. Вершины соединены направленными дугами, которые называют ветвями дерева. Начальный узел называют корнем. Если элемент не имеет ни одного потомка, он называется листом или терминальным узлом. Остальные элементы называются узлами. Каждое дерево обладает следующими свойствами: 1) Существует узел, в который не входит ни одной дуги (корень); 2) В каждую вершину входит только одна дуга кроме корня.
Степенью у вершины в дереве называется количество дуг, которое из нее выходит. Степень дерева равна максимальной степени вершины, входящей в дерево. По величине степени различают два типа деревьев: двоичные(степень не более двух), сильно ветвящиеся(степень дерева произвольная).
Высота (глубина дерева) определяется количеством уровней, на которых располагаются его вершины. Высота пустого дерева равна нулю, высота дерева из одного корня - 1. Корень дерева расположен на нулевом уровне. 
Число ветвей, которое нужно пройти от корня к узлу, называется длиной пути.
Корень имеет длину пути равную нулю. Узел на уровне n имеет длину пути равню n. Поддерево - часть дерева. 
Деревья являются рекурсивными структурами, т.к. каждое поддерево является деревом. Т.о. дерево можно определить как рекурсивную структуру, в которой каждый элемент является либо пустой структурой, либо элементом, с которым связано конечное число поддеревьев. 
Для того, чтобы выполнить операцию на всеми вершинами дерева, необходимо просмотреть все его вершины. Такая задача называется обходом дерева. Обход дерева - упорядоченная последовательность вершин, в которой каждая вершина встречается только один раз. При обходе все вершины дерева должны посещаться в определенном порядке. Существует несколько способов обхода всех вершин дерева.
1. Прямой (PreOrder)
void PreOrder(Tree t) {
	if (t != null) {
		<обработка t->info>
		PreOrder(t->left);
		PreOrder(t->right);
	}
}
2. Симметричный (InOrder)
3. Обратный (PostOrder)

В различных задачах применяются различные виды деревьев:
1. При разработке парсера(Парсер - программа, используемая для сбора информации с сайтов для последующего размещения на собственных) или транслятора (синтаксическое дерево). 
2. При работе со строчками (суффиксное дерево)
3. При разработке оптимальных алгоритмов на граф - струк данных в виде кучи (Куча - дерево, в котором каждому объекту присваивается приоритет. Наверху кучи находится объект с максимальным приоритетом. Внутренние узлы дерева содержат объект с меньшим приоритетом. Листья этого дерева имеют самый низкий приоритет.)
4. При реализации словарей в двоичном дереве поиска. 

Бинарные деревья
Это дерево, в котором каждая вершина имеет не более двух потомков. Каждая вершина бинарного дерева явлется структурой, содержащей три или четыре вида полей: 1) Информационное поле(ключ вершины); 2) Служебное поле (может быть несколько или ни одного); 3) Указатель на левое поддерево; 4) Указатель на правое поддерево. В общем случае у бинарного на k-ом уровне может быть до 2^k вершин. Бинарное дерево называется полным, если оно содержит только полностью заполненные уровни, иначе - неполное дерево. Деревом поиска называется дерево, у которого для каждой вершины выполняется требование: значение ключей в левом поддереве меньше значения ключа родителя, а значение ключей в правом поддереве больше значения ключа родителя. Т.е. данные в бинарном дереве поиска хранятся в отсортированном виде. При каждой вставке нового или удаления существующего узла, отсортированный порядок дерева сохраняется. Идеально сбалансированным деревом называется дерево, у которого для каждой вершины выполняется требование:
Число вершин в правом и левом поддеревьях отличаются не больше чем на 1. Идеальную сбалансированность довольно трудно поддерживать. В некоторых случаях при добавлении и удалении элементов может потребоваться значительная перестройка дерева. В 1962 году советские математики Адельсон-Вельский и Ландис ввели менее строгое определине сбалансированности и доказали, что при таком определении процедуры добавления и удаления имеют логарифмическую сложность и сохраняют дерево сбалансированным. Дерево считается сбалансированным по АВЛ, если выполняется для каждой вершины: высота левого и правого поддеревьев различаются не более чем на 1. Не всякое сбалансированное по АВЛ дерево сбалансированно, но всякое сбалансированное дерево явлется сбалансированным по АВЛ. При операции добавления или удаления может произойти нарушение сбалансированности. В этом случае потребуются некоторые преобразования, ненарушающие упорядоченности дерева и способствующие лучшей сбалансированности. 

Продолжение лекции от 14 октября
typedef int TInfo
struct Node {
	TInfo info;
	Node *left, *right;
};
typedef Node* Tree;
Tree BuildBalanced(int count, ifstream& fin) {
	if (count == 0) return nullptr;
	else {
		int count_left = count / 2;
		int count_right = count - count_left - 1;
		Tree t = new Node;
		fin >> t->info;
		t->left = BuildBalanced(count_left, fin);
		t->right = BuildBalanced(count_right, fin);
		return t;
	}
}

Печать дерева
    7
  3
    6
1   
    5
  2
    4
void printTree(Tree t, int level) {
	if (t != nullptr) {
		printTree(t->right, level + 1);
		for (int i = 1; i <- level; i++) {
			std::cout << ' ';
		std::cout << t->info << std::endl;
		printtree(t->left, level + 1);
	}
}

void deleteTree(Tree& t) {
	if (t != nullptr) {
		deleteTree(t->left);
		deleteTree(t->right);
		delete t;
		t = nullptr;
	}
}

class BinaryTree {
private: 
	Tree root;
public:
	BinaryTree(string fileName) {
		std::ifstream fin(fileName);
		int count;
		fin >> count;
		root = BuildBalanced(count, fin);
		fin.close();
	}
	voir print() {
		printTree(root, 0);
	}
	~BinaryTree() {
		deleteTree(root);
	}
	Tree GetTree() {
		return root;
	}
	int count(Tree t) {
		if (t == nullptr) return 0;
		else {
			int count;
			if (t->info % 2 == 0) count = 1;
			else count = 0;
			return count + count(t->left) + count(t->right);
		}
	}