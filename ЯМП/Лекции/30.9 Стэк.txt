Stack
FILO(first in - last out)
LIFO(last in - first out)

Структура данных, данные в котором организованы так, что доступен только один элемент,
называемый вершиной стека, остальные элементы недоступны. Добавление и извлечение элементов
производится из вершины - такой метод доступа называется FILO(first in - last out),
т.е. элементы извлекаются в порядке, обратном их добавлению.
Стек применяется для временного сохранения некоторой работы, которая еще не выполнена
до конца при необходимости переключения на другую задачу. По окончании ее выполнения
состояние отложенной задачи восстанавливается, и компьютер продолжает прерванную работу.
Одной из наиболее важных применений стека - организация вызова подпрограмм (стек вызовов).
При вызове подпрограммы или возникновение прерывания в стек заносится адрес возврата -
адрес в памяти, следующей инструкции, приостановленной программы. Управление передается
подпрограмме. При последующем вложенном или рекурсивном вызове, прерывании или обработчика
прерывания в стек заносится заносится очередной адрес возврата и т.д.
При возврате исход или обработчика прерывания адрес возврата снимается со стека,
и управление передается на следующую инструкцию приостановленной подпрограммы.
Кроме адресов возврата в стеке могут сохраняться и другие данные, например:
    значения регистров с их последующим восстановлением;
    аргументы, переданные в функцию;
    локальные переменные и другие произвольные данные
В большинстве процессоров стек возврата реализован аппаратно в системе комманд.
Программный вид стека используется для обхода структур данных например деревьев или графов.
Стек чаще всего реализуется на основе одномерных массивов, односвязных и двусвязных списков.
Основные операции над стеком:
1. инициализация (init)
2. проверка на пустоту (empty)
3. добавление элемента (push)
4. удаление элемента (pop)
5. чтение верхнего элемента (top)
6. просмотр элементов (view)

Реализация с помощью массива
{
const int max = 100;

typedef char TInfo;
typedef TInfo TElements[max];

class Stack {
    private:
    TElements elements;
    int top;
    public:
    Stack();
    bool Empty();
    bool Full();
    void Push(TInfo elem);
    TInfo Pop();
    TInfo Top();
    void View();
}
}

int Calculate(std::string fileName) {
    std::ifstream f("input.txt");
    Stack s;
    char c;
    while (f.get(c)) {
        if (c == 'M' || c == 'm' || c >= '0' && c <= '9')
            s.Push(c);
        else
            if (c == ')') {
                char c1 = s.Pop(), c2 = s.Pop(), op = s.Pop();
                switch (op) {
                    case 'M':
                        if (c1 > c2) s.Push(c1);
                        else s.Push(c2);
                        break;
                    case 'm':
                        if (c1 < c2) s.Push(c1);
                        else s.Push(c2);
                        break;
                }
            }
    }
    f.close();
    return s.Pop() - '0';
}



Очередь Queue
head
tail
FIFO(first in - first out)

Упорядоченный набор элементов, в котором данные организованы таким образом, что доступны только два элемента:
первый(head) и последний(tail). Добавление элементов осуществляется в конец очереди. Извлечение из головы.
Такой метод доступа называется FIFO(first in - first out), т.е. элементы извлекаются в порядке их добавления.
Области применения очередей могут быть разделены на две группы:
1. Системное применение. К применению в системных целях относят:
    Диспетчеризация задач операционной системой (обслуживание запросов в тех случаях, когда они не могут быть
    выполнены мгновенно, например при нажатии клавиши происходит прерывание работы компьютера, он запоминает свое состояние
    и переключается на обработку нажатия клавиши
    Буферизация ввода/вывода
2. Прикладное применение.
    Моделирование процессов(система массового обслуживания)
    Использование очередей как вспомогательных структур в каких-либо алгоритмах(Обход дерева или графа)
Очередь чаще всего реализуется на основе одномерных массивов (линейных и кольцевых), односвязных и двусвязных списков
Основные операции над стеком:
инициализация (init)
проверка на пустоту (empty)
добавление элемента (enqueue) - поставить в очередь
удаление элемента (dequeue) - убрать из очереди
чтение верхнего элемента (head)
просмотр элементов (view)

typedef char TInfo;

class Node {
    TInfo info;
    Node* next;
}

typedef Node* TList;

class Queue {
private:
    TList head, tail;
public:
    Queue() {
        head = nullptr;
    }
    bool Empty() {
        return head == nullptr;
    }
    void Enqueue(TInfo elem) {
        TList p = new Node;
        ...
    }
    void View();
}